<!DOCTYPE html>
<html>
<head>
  <title>3D Visualization</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.140.0/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0, 1, 1).normalize();
    scene.add(light);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;

    const gridHelper = new THREE.GridHelper(300, 300);
    scene.add(gridHelper);

    camera.position.set(150, 150, 400);
    camera.lookAt(150, 150, 150);

    const dataUrl = 'data.bin';  // Update this to the correct path
    const timesteps = [];
    let currentTimestep = 0;

    const pointsPerTimestep = 27e6;
    const subsampleRate = 300; // Adjust based on performance

    async function fetchBinaryData(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        return new Float32Array(arrayBuffer);
      } catch (error) {
        console.error("Error fetching binary data:", error);
        return null;
      }
    }

    fetchBinaryData(dataUrl).then(data => {
      if (data) {
        const valuesPerTimestep = pointsPerTimestep * 4;
        for (let i = 0; i < data.length; i += valuesPerTimestep) {
          timesteps.push(data.slice(i, i + valuesPerTimestep));
        }
        console.log("Timesteps processed:", timesteps.length); // Log processed timesteps count

        // Log some sample data for inspection
        if (timesteps.length > 0) {
          console.log("Sample timestep data (pressure):", timesteps[3].slice(0, 10));
          console.log("Sample timestep data (u):", timesteps[3].slice(pointsPerTimestep, pointsPerTimestep + 10));
          console.log("Sample timestep data (v):", timesteps[3].slice(2 * pointsPerTimestep, 2 * pointsPerTimestep + 10));
          console.log("Sample timestep data (w):", timesteps[3].slice(3 * pointsPerTimestep, 3 * pointsPerTimestep + 10));
        }

        updateScene(timesteps[currentTimestep]);
      } else {
        console.error("No data to process");
      }
    });

    function updateScene(timestepData) {
      if (!timestepData) {
        console.error("No timestep data available for update.");
        return;
      }

      console.log("Updating scene with timestep data:", timestepData); // Log the timestep data

      while (scene.children.length > 0) {
        const obj = scene.children[0];
        if (obj !== gridHelper && obj !== light) {
          scene.remove(obj);
        } else {
          break;
        }
      }

      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const colors = [];

      for (let i = 0; i < pointsPerTimestep; i += subsampleRate) {
        const p = timestepData[i];
        const u = timestepData[pointsPerTimestep + i];
        const v = timestepData[2 * pointsPerTimestep + i];
        const w = timestepData[3 * pointsPerTimestep + i];

        const x = i % 300;
        const y = Math.floor((i / 300) % 300);
        const z = Math.floor(i / (300 * 300));

        vertices.push(x, y, z);

        const color = getColorFromPressure(p);
        colors.push(color.r, color.g, color.b);

        const arrow = createArrow({ x, y, z }, { x: u, y: v, z: w });
        scene.add(arrow);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.1 });
      const points = new THREE.Points(geometry, material);
      scene.add(points);
    }

    function getColorFromPressure(pressure) {
      if (timesteps.length === 0) {
        console.error("No timesteps available to determine pressure range.");
        return new THREE.Color(0, 0, 0); // Return black color
      }
      const minP = Math.min(...timesteps[0].slice(0, pointsPerTimestep));
      const maxP = Math.max(...timesteps[0].slice(0, pointsPerTimestep));
      const color = new THREE.Color();
      color.setHSL((pressure - minP) / (maxP - minP), 1.0, 0.5);
      return color;
    }

    function createArrow(position, velocity) {
      const dir = new THREE.Vector3(velocity.x, velocity.y, velocity.z).normalize();
      const origin = new THREE.Vector3(position.x, position.y, position.z);
      const length = Math.sqrt(velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2) / 10;
      const hex = 0xffff00;
      return new THREE.ArrowHelper(dir, origin, length, hex);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    setInterval(() => {
      currentTimestep = (currentTimestep + 1) % timesteps.length;
      if (timesteps.length > 0) {
        updateScene(timesteps[currentTimestep]);
      }
    }, 300);

    animate();
  </script>
</body>
</html>
